
Description="Maple"

Keywords={
  { Id=1,
    List={"and", "or", "xor", "union", "intersect", "minus", "mod", "not", 
        "assuming", "break", "by", "catch", "description", "do", "done", "elif",  
        "else",  "end", "error", "export", "fi", "finally", "for", "from", "global", 
        "if", "implies", "in", "local", "module", "next", "od", "option", "options",  
        "proc", "quit", "read", "return", "save", "stop", "psubset", "then", "to", 
        "try", "use", "while", "true", "false"},
  },
  { Id=2,
    List={"about", "ans", "add", "addcoords", "additionally", "addproperty", 
        "addressof", "AFactor", "AFactors", "AIrreduc", "AiryAi", "AiryAiZeros", 
        "AiryBi", "AiryBiZeros", "algebraic", "algsubs", "alias", "allvalues", "anames", 
        "AngerJ", "antihermitian", "antisymm", "apply", "applyop", "applyrule", 
        "arccos", "arccosh", "arccot", "arccoth", "arccsc", "arccsch", "arcsec", 
        "arcsech", "arcsin", "arcsinh", "arctan", "arctanh", "argument", "Array", 
        "array", "ArrayDims", "ArrayElems", "ArrayIndFns", "ArrayOptions", "assign", 
        "assigned", "asspar", "assume", "asympt", "attributes", "band", "Berlekamp", 
        "bernoulli", "bernstein", "BesselI", "BesselJ", "BesselJZeros", "BesselK", 
        "BesselY", "BesselYZeros", "Beta", "branches", "C", "cat", "ceil", 
        "changecoords", "charfcn", "ChebyshevT", "ChebyShevU", "CheckArgs", "Chi", 
        "chrem", "Ci", "close", "coeff", "coeffs", "coeftayl", "collect", "combine", 
        "comparray", "compiletable", "compoly", "CompSeq", "conjugate", "constant", 
        "Content", "content", "convergs", "convert", "coords", "copy", "CopySign", 
        "cos", "cosh", "cot", "coth", "coulditbe", "csc", "csch", "csgn", "currentdir", 
        "curry", "CylinderD", "CylinderU", "CylinderV", "D", "dawson", "Default0", 
        "DefaultOverflow", "DefaultUnderflow", "define", "define_external", "degree", 
        "denom", "depends", "DESol", "Det", "diagon", "Diff", "diff", "diffop", 
        "Digits", "dilog", "dinterp", "Dirac", "disassemble", "discont", "discrim", 
        "dismantle", "DistDeg", "Divide", "divide", "dsolve", "efficiency", "Ei", 
        "Eigenvals", "eliminate", "ellipsoid", "EllipticCE", "EllipticCK", 
        "EllipticCPi", "EllipticE", "EllipticF", "EllipticK", "EllipticModulus", 
        "EllipticNome", "EllipticPi", "elliptic_int", "entries", "erf", "erfc", "erfi", 
        "euler", "eulermac", "Eval", "eval", "evala", "evalapply", "evalb", "evalc", 
        "evalf", "evalfint", "evalhf", "evalm", "evaln", "evalr", "evalrC", "events", 
        "Excel", "exists", "exp", "Expand", "expand", "expandoff", "expandon", 
        "exports", "extract", "extrema", "Factor", "factor", "Factors", "factors", 
        "fclose", "fdiscont", "feof", "fflush", "FFT", "filepos", "fixdiv", "float", 
        "floor", "fnormal", "fold", "fopen", "forall", "forget", "fprintf", "frac", 
        "freeze", "frem", "fremove", "FresnelC", "Fresnelf", "Fresnelg", "FresnelS", 
        "FromInert", "frontend", "fscanf", "fsolve", "galois", "GAMMA", "GaussAGM", 
        "Gausselim", "Gaussjord", "gc", "Gcd", "gcd", "Gcdex", "gcdex", "GegenbauerC", 
        "genpoly", "getenv", "GetResultDataType", "GetResultShape", "GF", "Greek", 
        "HankelH1", "HankelH2", "harmonic", "has", "hasfun", "hasoption", "hastype", 
        "heap", "Heaviside", "Hermite", "HermiteH", "hermitian", "Hessenberg", 
        "hfarray", "history", "hypergeom", "icontent", "identity", "IEEEdiffs", 
        "ifactor", "ifactors", "iFFT", "igcd", "igcdex", "ilcm", "ilog10", "ilog2", 
        "ilog", "Im", "implicitdiff", "ImportMatrix", "ImportVector", "indets", "index", 
        "indexed", "indices", "inifcn", "ininame", "initialcondition", "initialize", 
        "insert", "int", "intat", "interface", "Interp", "interp", "Inverse", "invfunc", 
        "invztrans", "iostatus", "iperfpow", "iquo", "iratrecon", "irem", "iroot", 
        "Irreduc", "irreduc", "is", "iscont", "isdifferential", "IsMatrixShape", 
        "isolate", "isolve", "ispoly", "isprime", "isqrfree", "isqrt", "issqr", 
        "ithprime", "JacobiAM", "JacobiCD", "JacobiCN", "JacobiCS", "JacobiDC", 
        "JacobiDN", "JacobiDS", "JacobiNC", "JacobiND", "JacobiNS", "JacobiP", 
        "JacobiSC", "JacobiSD", "JacobiSN", "JacobiTheta1", "JacobiTheta2", 
        "JacobiTheta3", "JacobiTheta4", "JacobiZeta", "KelvinBei", "KelvinBer", 
        "KelvinHei", "KelvinHer", "KelvinKei", "KelvinKer", "KummerM", "KummerU", 
        "LaguerreL", "LambertW", "latex", "lattice", "lcm", "Lcm", "lcoeff", "leadterm", 
        "LegendreP", "LegendreQ", "length", "LerchPhi", "lexorder", "lhs", "CLi", 
        "Limit", "limit", "Linsolve", "ln", "lnGAMMA", "log", "log10", "LommelS1", 
        "Lommels2", "lprint", "map", "map2", "Maple_floats", "match", "MatlabMatrix", 
        "Matrix", "matrix", "MatrixOptions", "max", "maximize", "maxnorm", "maxorder", 
        "MeijerG", "member", "min", "minimize", "mkdir", "ModifiedMeijerG", "modp", 
        "modp1", "modp2", "modpol", "mods", "module", "MOLS", "msolve", "mtaylor", 
        "mul", "NextAfter", "nextprime", "nops", "norm", "norm", "Normal", "normal", 
        "nprintf", "Nullspace", "numboccur", "numer", "NumericClass", "NumericEvent", 
        "NumericEventHandler", "NumericException", "numerics", "NumericStatus", 
        "odetest", "op", "open", "order", "OrderedNE", "parse", "patmatch", "pclose", 
        "PDEplot_options", "pdesolve", "pdetest", "pdsolve", "piecewise", "plot", 
        "plot3d", "plotsetup", "pochhammer", "pointto", "poisson", "polar", "polylog", 
        "polynom", "Power", "Powmod", "powmod", "Prem", "prem", "Preprocessor", 
        "prevprime", "Primitive", "Primpart", "primpart", "print", "printf", 
        "ProbSplit", "procbody", "ProcessOptions", "procmake", "Product", "product", 
        "proot", "property", "protect", "Psi", "psqrt", "queue", "Quo", "quo", 
        "radfield", "radnormal", "radsimp", "rand", "randomize", "Randpoly", "randpoly", 
        "Randprime", "range", "ratinterp", "rationalize", "Ratrecon", "ratrecon", "Re", 
        "readbytes", "readdata", "readlib", "readline", "readstat", "realroot", 
        "Record", "Reduce", "references", "release", "Rem", "rem", "remove", 
        "repository", "requires", "residue", "RESol", "Resultant", "resultant", "rhs", 
        "rmdir", "root", "rootbound", "RootOf", "Roots", "roots", "round", "Rounding", 
        "rsolve", "rtable", "rtable_algebra", "rtable_dims", "rtable_elems", 
        "rtable_indfns", "rtable_options", "rtable_printf", "rtable_scanf", 
        "SampleRTable", "savelib", "Scale10", "Scale2", "scalar", "scan", "scanf", 
        "SearchText", "searchtext", "sec", "sech", "select", "selectfun", 
        "selectremove", "seq", "series", "setattribute", "SFloatExponent", 
        "SFloatMantissa", "shale", "Shi", "showprofile", "showtime", "Si", "sign", 
        "signum", "Simplify", "simplify", "sin", "sinh", "singular", "sinterp", 
        "smartplot3d", "Smith", "solve", "solvefor", "sort", "sparse", "spec_eval_rule", 
        "spline", "spreadsheet", "SPrem", "sprem", "sprintf", "Sqrfree", "sqrfree", 
        "sqrt", "sscanf", "Ssi", "ssystem", "storage", "string", "StruveH", "StruveL", 
        "sturm", "sturmseq", "subs", "subsindets", "subsop", "substring", "subtype", 
        "Sum", "sum", "surd", "Svd", "symmdiff", "symmetric", "syntax", "system", 
        "table", "tan", "tang", "taylor", "testeq", "testfloat", "TEXT", "thaw", 
        "thiele", "time", "timelimit", "ToInert", "TopologicalSort", "traperror", 
        "triangular", "trigsubs", "trunc", "type", "typematch", "unames", "unapply", 
        "unassign", "undefined", "unit", "Unordered", "unprotect", "update", 
        "UseHardwareFloats", "userinfo", "value", "Vector", "vector", "verify", 
        "WeierstrassP", "WeberE", "WeierstrassPPrime", "WeierstrassSigma", 
        "WeierstrassZeta", "whattype", "WhittakerM", "WhittakerW", "with", "worksheet", 
        "writebytes", "writedata", "writeline", "writestat", "writeto", "zero", "Zeta", 
        "zip", "ztrans"},
  },
  { Id=4,
    Regex=[[(\w+)\s*\(]],
  },
}

Strings={
  Delimiter=[["|'|`]],
}

IgnoreCase=false

Comments={
  { Block=false,
    Delimiter= { [[\/\/]] },
  },
}

Operators=[[\(|\)|\[|\]|\{|\}|\,|\;|\:|\&|<|>|\!|\=|\/|\*|\%|\+|\-|\^]]
